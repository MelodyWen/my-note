# kubernetes 是什么
> 1.参考 《Kubernetes 权威指南》
> 2. https://kuboard.cn/learning/k8s-bg/what-is-k8s.html#%E5%9B%9E%E9%A1%BE

## 第一部分 《Kubernetes 权威指南》
在 kubernetes 中， Service 是分布式集群架构的核心，一个Service 对象拥有如下关键的特征：
- 拥有一个唯一指定的名字；
- 拥有一个虚拟的IP和端口号：
- 能够提供某种远程服务能力；
- 被映射到了提供这种服务能力的一组容器应用上；


kubernetes 设计了Pod 对象，把每个服务进程包装到相应的Pod中，是 其成为Pod中运行的容器；
> 容器提供了强大 的隔离功能，所以有必要把为Service提供服务的这组进程放入容器中进行隔离。
> 1. 每个Pod 打上合适的Label ；
> 2. 相应的Service 定义标签选择器
> 3. 这样Pod 和Service 就进行巧妙的关联了；

#### 简单介绍Pod
首先Pod 运行在节点上，节点既可以是物理机，也可以是私有云或者公有云的一个虚拟机。

通常一个节点上运行几百个Pod：
- 每个Pod 里运行着一个特殊的被称为Pause的容器
- 其他的容器则全部为业务容器；
  - 业务容器会共享Pause 容器的 网络栈 和Volume 挂载卷，因此它们之间的通讯和数据交换更加的高效。
    - 所以，优先考虑将一组密切关联的服务进程放入到同一个Pod；
- 提供服务的一组Pod 可以映射到一个Service上

#### 集群管理方面
kubernetes 将集群划分为一个Master节点和一群工作节点（Node）

Master节点上运行着集群管理相关的一组进程：
> 这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控 和纠错等管理功能，并且都是全自动完成的。

- kube-apiserver
- kube-controller-manager
- kube-scheduler

Node 作为集群中的工作节点，运行真正的应用程序，Node上Kubernetes 管理的最小运行单元是Pod。
> 下面的这些服务进程负责Pod 的创建、启动、监控、重启、销毁、以及实现软件模式的负载均衡器。

- Kubelet
- Kube-proxy

#### Replication Controller(RC) 服务扩容和服务升级
在Kubernetes集群中，只需要为需要扩容的Service 关联的Pod 创建一个 Replication Controller（RC） ，就能完成相应的服务扩容和升级。

在RC定义文件中包括以下三个关键的信息：（其余的部分，都是Kubernetes 全自动完成）
- 目标Pod的定义；
- 目标Pod需要运行的副本数量
- 要监控的目标Pod的标签；

## 第二部分 kuboard
## 第一节 Kubernetes 是什么
大致来说，在部署应用程序的方式上，我们主要经历了三个时代：

- **传统部署时代**：早期，企业直接将应用程序部署在物理机上。由于物理机上不能为应用程序定义资源使用边界，我们也就很难合理地分配计算资源。例如：如果多个应用程序运行在同一台物理机上，可能发生这样的情况：其中的一个应用程序消耗了大多数的计算资源，导致其他应用程序不能正常运行。应对此问题的一种解决办法是，将每一个应用程序运行在不同的物理机上。然而，这种做法无法大规模实施，因为资源利用率很低，且企业维护更多物理机的成本昂贵。
- **虚拟化部署时代**：针对上述问题，虚拟化技术应运而生。用户可以在单台物理机的CPU上运行多个虚拟机（Virtual Machine）。
    - 虚拟化技术使得应用程序被虚拟机相互分隔开，限制了应用程序之间的非法访问，进而提供了一定程度的安全性。
    - 虚拟化技术提高了物理机的资源利用率，可以更容易地安装或更新应用程序，降低了硬件成本，因此可以更好地规模化实施。
    - 每一个虚拟机可以认为是被虚拟化的物理机之上的一台完整的机器，其中运行了一台机器的所有组件，包括虚拟机自身的操作系统。
- **容器化部署时代**：容器与虚拟机类似，但是降低了隔离层级，共享了操作系统。因此，容器可以认为是轻量级的。
    - 与虚拟机相似，每个容器拥有自己的文件系统、CPU、内存、进程空间等
    - 运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
    - 容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署

容器化越来越流行，主要原因是它带来的诸多好处：
- **敏捷地创建和部署应用程序**：相较于创建虚拟机镜像，创建容器镜像更加容易和快速
- **持续构建集成**：可以更快更频繁地构建容器镜像、部署容器化的应用程序、并且轻松地回滚应用程序
- **分离开发和运维的关注点**：在开发构建阶段就完成容器镜像的构建，构建好的镜像可以部署到多种基础设施上。这种做法将开发阶段需要关注的内容包含在如何构建容器镜像的过程中，将部署阶段需要关注的内容聚焦在如何提供基础设施以及如何使用容器镜像的过程中。降低了开发和运维的耦合度
- **可监控性**：不仅可以查看操作系统级别的资源监控信息，还可以查看应用程序健康状态以及其他信号的监控信息
- **开发、测试、生产不同阶段的环境一致性**：开发阶段在笔记本上运行的容器与测试、生产环境中运行的容器一致
- **跨云服务商、跨操作系统发行版的可移植性**：容器可运行在 Ubuntu、RHEL、CoreOS、CentOS等不同的操作系统发行版上，可以运行在私有化部署、Google Kubernetes Engine、AWS、阿里云等不同的云供应商的环境中
- **以应用程序为中心的管理**：虚拟机时代的考虑的问题是在虚拟硬件上运行一个操作系统，而容器化时代，问题的焦点则是在操作系统的逻辑资源上运行一个应用程序
- **松耦合、分布式、弹性、无约束的微服务**：应用程序被切分成更小的、独立的微服务，并可以动态部署和管理，而不是一个部署在专属机器上的庞大的单片应用程序
- **资源隔离**：确保应用程序性能不受干扰
- **资源利用**：资源高效、高密度利用

### Kubernetes的功能

容器是一个非常好的打包并运行应用程序的方式。在生产环境中，您需要管理容器化应用程序，并且确保其不停机地连续运行。例如：一个容器故障停机，另外一个容器需要立刻启动以替补停机的容器。类似的这种对容器的管理动作由系统来执行会更好更快速。

Kubernetes针对此类问题，提供了容器化编排解决方案，可以使你非常健壮地运行分布式系统。Kubernetes可以处理应用程序的伸缩、failover、部署模式等多种需求。例如，Kubernetes可以轻易地管理系统的金丝雀发布（灰度发布）。

##### Kubernetes提供的特性有：

- **服务发现和负载均衡**: Kubernetes 可以通过 DNS 名称或 IP 地址暴露容器的访问方式。并且可以在同组容器内分发负载以实现负载均衡
- **存储编排**:Kubernetes可以自动挂载指定的存储系统，例如 local stroage/nfs/云存储等
- **自动发布和回滚**:您可以在 Kubernetes 中声明您期望应用程序容器应该达到的状态，Kubernetes将以合适的速率调整容器的实际状态，并逐步达到最终期望的结果。请参考 声明式的配置
- **自愈**:Kubernetes提供如下自愈能力：
    - 重启已经停机的容器
    - 替换、kill 那些不满足自定义健康检查条件的容器
    - 在容器就绪之前，避免调用者发现该容器

- **密钥及配置管理**: Kubernetes可以存储和管理敏感信息（例如，密码、OAuth token、ssh密钥等）。您可以更新容器应用程序的密钥、配置等信息，而无需：
    - 重新构建容器的镜像
    - 在不合适的地方暴露密码信息

### Kubernetes的边界
Kubernetes不是一个传统意义的、保罗万象的 PaaS（Platform as a Service）系统。Kubernetes在容器层面工作，而不是硬件层面，它提供了与 PaaS 平台相似的通用特性，例如：部署、伸缩、负载均衡、日志、监控等。然而，Kubernetes并不是一个单一整体，这些特性都是可选、可插拔的。Kubernetes提供用于搭建开发平台的基础模块，同时为用户提供了不同模块的选择性和多样性。

Kubernetes：

- 不限制应用程序的类型。Kubernetes的目标是广泛支持不同类型的工作负载，包括：有状态、无状态、数据处理等类型的应用。只要应用可以在容器中运行，就能够非常好地在 Kubernetes 上运行
- 不部署源码、不编译或构建应用程序。持续集成、分发、部署（CI/CD）的工作流极大程度上取决于组织的文化、偏好以及技术要求。Kubernetes可以作为部署平台参与到 CI/CD 流程，但是不涉及镜像构建和分发的过程
> 译者注：可选的有 Jenkins / Gitlab Runner / docker registry / harbour 等

- 不提供应用程序级别的服务，包括：中间件（例如，消息总线）、数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存（例如，Redis），或者分布式存储（例如，Ceph）。此类组件可以在 Kubernetes 上运行，或者可以被运行在 Kubernetes 上的应用程序访问
- 不限定日志、监控、报警的解决方案。Kubernetes 提供一些样例展示如何与日志、监控、报警等组件集成，同时提供收集、导出监控度量（metrics）的一套机制。您可以根据自己的需要选择日志、监控、报警组件
> 译者注：可选的有 ELK / Prometheus / Graphana / Pinpoint / Skywalking / Metrics Server 等

- 不提供或者限定配置语言（例如，jsonnet）。Kubernetes提供一组声明式的 API，您可以按照自己的方式定义部署信息。
> 译者注：可选的有 helm/kustomize/kubectl/kubernetes dashboard/kuboard/octant/k9s 等

- 不提供或限定任何机器的配置、维护、管理或自愈的系统。
> 译者注：在这个级别上，可选的组件有 puppet、ansible、open stack 等

- 此外，Kubernetes不是一个纯粹意义上的容器编排系统。事实上，Kubernetes 消除了容器编排的需求。容器编排的技术定义是预定义流程的执行（先做A、再做B、然后做C）。与此相对应，Kubernetes构建了一系列相互独立、可预排的控制过程，以持续不断地将系统从当前状态调整到声明的目标状态。如何从 A 达到 C，并不重要。集中化的控制也就不需要了。这个设计思想使得Kubernetes使用更简单、更强大、稳健、反脆弱和可扩展

## 第二节 Kubernetes组件
## Master组件是集群的控制平台（control plane）：
- master 组件负责集群中的全局决策（例如，调度）
- master 组件探测并响应集群事件（例如，当 Deployment 的实际 Pod 副本数未达到 replicas 字段的规定时，启动一个新的 Pod）

Master组件可以运行于集群中的任何机器上。但是，为了简洁性，通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器。参考 [安装Kubernetes高可用](https://kuboard.cn/install/install-kubernetes.html)。

#### kube-apiserver
此 master 组件提供 Kubernetes API。这是Kubernetes控制平台的前端（front-end），可以水平扩展（通过部署更多的实例以达到性能要求）。`kubectl` / `kubernetes dashboard` / `kuboard` 等`Kubernetes管理工具`就是通过 kubernetes API 实现对 Kubernetes 集群的管理。

#### etcd
支持一致性和高可用的名值对存储组件，Kubernetes集群的所有配置信息都存储在 etcd 中。请确保您 备份 了 etcd 的数据。关于 etcd 的更多信息，可参考 etcd 官方文档

##### kube-scheduler
此 master 组件监控所有新创建尚未分配到节点上的 Pod，并且自动选择为 Pod 选择一个合适的节点去运行。

影响调度的因素有：

- 单个或多个 Pod 的资源需求
- 硬件、软件、策略的限制
- 亲和与反亲和（affinity and anti-affinity）的约定
- 数据本地化要求
- 工作负载间的相互作用

#### kube-controller-manager
此 master 组件运行了所有的控制器

逻辑上来说，每一个控制器是一个独立的进程，但是为了降低复杂度，这些控制器都被合并运行在一个进程里。

kube-controller-manager 中包含的控制器有：

- 节点控制器： 负责监听节点停机的事件并作出对应响应
- 副本控制器： 负责为集群中每一个 副本控制器对象（Replication Controller Object）维护期望的 Pod 副本数
- 端点（Endpoints）控制器：负责为端点对象（Endpoints Object，连接 Service 和 Pod）赋值
- Service Account & Token控制器： 负责为新的名称空间创建 default Service Account 以及 API Access Token

## Node 组件
Node 组件运行在每一个节点上（包括 master 节点和 worker 节点），负责维护运行中的 Pod 并提供 Kubernetes 运行时环境。

#### kubelet
此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。

#### kube-proxy
kube-proxy 是一个网络代理程序，运行在集群中的每一个节点上，是实现 Kubernetes Service 概念的重要部分。

kube-proxy 在节点上维护网络规则。这些网络规则使得您可以在集群内、集群外正确地与 Pod 进行网络通信。如果操作系统中存在 packet filtering layer，kube-proxy 将使用这一特性（iptables代理模式），否则，kube-proxy将自行转发网络请求（User space代理模式）

#### 容器引擎
容器引擎负责运行容器。Kubernetes支持多种容器引擎：Docker、containerd、cri-o、rktlet 以及任何实现了 Kubernetes容器引擎接口 的容器引擎

## Addons
Addons 使用 Kubernetes 资源（DaemonSet、Deployment等）实现集群的功能特性。由于他们提供集群级别的功能特性，addons使用到的Kubernetes资源都放置在 kube-system 名称空间下。

下面描述了一些经常用到的 addons，参考 Addons 查看更多列表。

## DNS
除了 DNS Addon 以外，其他的 addon 都不是必须的，所有 Kubernetes 集群都应该有 Cluster DNS

Cluster DNS 是一个 DNS 服务器，是对您已有环境中其他 DNS 服务器的一个补充，存放了 Kubernetes Service 的 DNS 记录。

Kubernetes 启动容器时，自动将该 DNS 服务器加入到容器的 DNS 搜索列表中。

> 如果您参考 www.kuboard.cn 上提供的文档安装 Kubernetes，默认已经安装了 Core DNS

## Web UI（Dashboard）
[Dashboard](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/) 是一个Kubernetes集群的 Web 管理界面。用户可以通过该界面管理集群。

## Kuboard
[Kuboard](https://kuboard.cn/install/install-dashboard.html) 是一款基于Kubernetes的微服务管理界面，相较于 Dashboard，Kuboard 强调：

- 无需手工编写 YAML 文件
- 微服务参考架构
- 上下文相关的监控
- 场景化的设计
    - 导出配置
    - 导入配置

## ContainerResource Monitoring
Container Resource Monitoring 将容器的度量指标（metrics）记录在时间序列数据库中，并提供了 UI 界面查看这些数据

## Cluster-level Logging
Cluster-level logging 机制负责将容器的日志存储到一个统一存储中，并提供搜索浏览的界面
